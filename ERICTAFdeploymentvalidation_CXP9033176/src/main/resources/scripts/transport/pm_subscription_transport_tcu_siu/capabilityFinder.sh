#!/bin/bash
#===================================================================================
#
# FILE: capabilityFinder.sh
#
# USAGE: sh capabilityFinder.sh
#
# DESCRIPTION: Triggers full sync on nodes parallely using ssh/openssli
#              <JOB_ID> : any string
#              <JOB_FILE> : .job file generated by running collector.sh
#              <LOGGING> : true/false - generates log file per node
#       
# AUTHOR: ZPALSRI(srihari.palivela@tcs.com)
# VERSION: 1.0
# CREATED: 15.03.2018 
#
#===================================================================================


if [[ $# -ne 6 ]];then
    echo "Invalid number of parameters"
    echo "Usage : sh $0 <INIT_NUM_NODES> <STEP_NODES> <DEST> <DEST_PATH> <START_FAIL_ROP> <MAX_FAIL_ROP>"
    exit 1
fi

echo_time() {
    date +"%D %T.%6N : $*"
}


START=$1
STEP=$2
DEST=$3
DEST_PATH=$4
START_FAIL_ROP=$5
MAX_FAIL_ROP=$6

MAX=`wc -l allNodes.job | awk '{print $1}'`

LOG="capabilityfinder.log"
TRIGGER_LOG="trigger.log"
ROP_LOG="rop.log"
CPU_LOG="cpu.log"
RES="result.csv"

rm -rf ${LOG}

#Start logging
sh logger.sh &
LOGGER_PID=$!

#Start counter
sh counter.sh &
COUNTER_PID=$!

# Number of ROPS to be failed -
NUM_FAIL_ROP=${START_FAIL_ROP}

while [ ${NUM_FAIL_ROP} -le ${MAX_FAIL_ROP} ];do

echo "Number of ROPs to be failed :"${NUM_FAIL_ROP} >> ${RES}	

	for i in {1..1};do

		# Time to wait for file to be pushed = Wait for next ROP + Generation ROP + ( n * ROPS to fail) 
		# Time to wait for triggering with correct destination = Wait for next ROP + Generation ROP + ( n-1 * ROPS to fail) + Transfer Time + 3 Min Buffer
	
		NODES=$START
		while [ true ];do
			if [ ${NUM_FAIL_ROP} -ne 0 ];then
				# Using invalid destination for inducing failed ROP
				# If a ROP Fails then in next ROP all previously failed ROP files 
				# will also be sent along with current ROP files
				sh trigger.sh $NODES $DEST ${DEST_PATH} 1 > run.log
				FAILED=`cat ${TRIGGER_LOG} | grep "timedout" | wc -l`
				EXPECTED_NODES=$((NODES - FAILED))
				#EXPECTED_NODES=`cat run.log |  grep commit_success |wc -l`
				echo_time " Fail ROP  : Expected successful nodes : ${EXPECTED_NODES}" >> $LOG
				CURR_MIN=`date +%M`
				REM_MIN=$(( 15 - ( $CURR_MIN %15 ) ))
				TIME_TO_SLEEP=$(( ( REM_MIN + 15 + ((NUM_FAIL_ROP - 1)* 15) + 5 + 3) * 60 ))
				echo_time "Sleeping for ${TIME_TO_SLEEP} seconds" >> $LOG			
				sleep ${TIME_TO_SLEEP}
				#sleep 10
			fi		
			UPLOAD_COUNT=0		
			echo_time "Fail Rop Waiting completed" >> $LOG
			sh trigger.sh $NODES $DEST ${DEST_PATH} 0 > run.log
			FAILED=`cat ${TRIGGER_LOG} | grep "timedout" | wc -l`
			EXPECTED_NODES=$((NODES - FAILED))
			#EXPECTED_NODES=`cat run.log |  grep commit_success |wc -l`
			UPLOAD_COUNT=0
			echo_time " Expected successful nodes : ${EXPECTED_NODES}" >> $LOG
			CURR_MIN=$(date +%M)
			REM_MIN=$(( 15 - ( $CURR_MIN %15 )))
			echo_time "test1" >> $LOG
			# Wait till log file generated which will be generated at 7th min
			# SLEEPTIME = REMAING_TIME_FOR_CURRENT_ROP+ TRANSFER_TIME +1 MIN BUFFER(Till 6th min log will be captured)
			SLEEPTIME=$(( ( REM_MIN + 6 ) * 60 ))
			echo_time "test2" >>$LOG
	 		echo_time "Sleeping for ${SLEEPTIME} seconds" >> $LOG
		        sleep ${SLEEPTIME}

			echo_time "Woke up" >> $LOG
			UPLOAD_COUNT=0
			CPU_LOG_FILE=""
			BREAK=0
			while [ true ];do
				CURR_MIN=`date +%M`
				echo_time "Waiting for 7th Minute of ROP" >> $LOG
				if (( ${CURR_MIN} % 15 == 7 ));then
					LAST_ROP_TRANSFER_TIME=`date --date="-9 minutes" +%d_%m_%H_%M`
					ROP_LOG_FILE="${LAST_ROP_TRANSFER_TIME}_${ROP_LOG}"
					CPU_LOG_FILE="${LAST_ROP_TRANSFER_TIME}_${CPU_LOG}"
					TIME=`date +"%d-%m-%y %H:%M:%S"`
					echo "${TIME}: Check for file :${ROP_LOG_FILE}" >> $LOG 
					if [ -f ${ROP_LOG_FILE} ];then
						ROP_START_TIME=`date --date="-7 minutes" "+%Y-%m-%d %H:%M:00"`
						echo_time "Checking in logs for ROP start: ${ROP_START_TIME}" >> $LOG
						START_ROP=`date -d"${ROP_START_TIME}" +%s`
						END_ROP=$(( START_ROP + 300 ))
						echo_time  "Start :${START_ROP} End : ${END_ROP} File : ${ROP_LOG_FILE}" >> $LOG
						sh extract.sh ${ROP_LOG_FILE} ropfile ${START_ROP} ${END_ROP}
						sh calculateCPU.sh ${CPU_LOG_FILE} ${START_ROP} ${END_ROP} 
						echo "Result of Extract : $?" >> $LOG
						UPLOAD_COUNT=`cat ropfile | grep "file_uploaded" | wc -l`
						echo_time "Total files uploaded @ ROP : ${LAST_ROP_TRANSFER_TIME} is ${UPLOAD_COUNT}" >> $LOG
						break
					# File won't be present if usecase was triggered after/during file transfer time 0-5th min of ROP
					else
						BREAK=1
						echo_time "${ROP_LOG_FILE} does not exist\n exiting ..">> $LOG
						break
					fi
				else
					sleep 60
				fi
			done
			if [[ $BREAK -eq 1 ]];then
				echo_time "Exiting loop" >>$LOG
				break
			fi

			EXPECTED_COUNT=$(( EXPECTED_NODES * 2))
			echo_time "Expected : ${EXPECTED_COUNT} , Observed Uploads : ${UPLOAD_COUNT}" >> $LOG
	
			if [[ ${UPLOAD_COUNT} -eq ${EXPECTED_COUNT}  ]];then
				echo_time "${NODES},${EXPECTED_NODES},${UPLOAD_COUNT},passed" >> ${RES}
				NODES=$(( NODES + STEP ))
				if [[ ${NODES} -gt $MAX ]];then
					break
				fi
			elif [[ ${UPLOAD_COUNT} -gt ${EXPECTED_COUNT} ]];then
				echo_time " : Got more uploads than expected, may be becuase of left out subscriptions/n Or/n Files from previouse ROP /nReset subscriptions/n" >> $LOG
				# clear all nodes
				sh cleanUp.sh $MAX
				echo_time " : ${NODES},${EXPECTED_NODES},${UPLOAD_COUNT},passed" >> ${RES}
		                NODES=$(( NODES + STEP ))
		                if [[ ${NODES} -gt $MAX ]];then
		                        break
		                fi
			else
				echo_time " : ${NODES},${EXPECTED_NODES},${UPLOAD_COUNT},failed" >> ${RES}			
				break
			fi
			sh removeFilesOnDest.sh $DEST ${DEST_PATH} 		
		done
		sh cleanUp.sh $MAX
		if [[ $BREAK -eq 1 ]];then
			break
		fi
	done
	if [[ $BREAK -eq 1 ]];then
		echo_time "Exiting loop" >>$LOG
		break
	fi
	NUM_FAIL_ROP=`expr ${NUM_FAIL_ROP} + 1`
done
sh removeFilesOnDest.sh $DEST ${DEST_PATH} 
ps -efl | grep logtool | grep -v "grep" | awk '{print $4}' | xargs kill
kill $LOGGER_PID
kill $COUNTER_PID
