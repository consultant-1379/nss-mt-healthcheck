package ConfigExtended;


/**
* ConfigExtended/NotificationProducerPOA.java .
* Generated by the IDL-to-Java compiler (portable), version "3.2"
* from configuration_ext_K.idl
* Tuesday, May 22, 2018 12:36:12 PM GMT+01:00
*/

public abstract class NotificationProducerPOA extends org.omg.PortableServer.Servant
 implements ConfigExtended.NotificationProducerOperations, org.omg.CORBA.portable.InvokeHandler
{

  // Constructors

  private static java.util.Hashtable _methods = new java.util.Hashtable ();
  static
  {
    _methods.put ("subscribe", new java.lang.Integer (0));
    _methods.put ("subscribe_ext", new java.lang.Integer (1));
    _methods.put ("subscribe_ext_v2", new java.lang.Integer (2));
    _methods.put ("unsubscribe", new java.lang.Integer (3));
    _methods.put ("get_subscription_status", new java.lang.Integer (4));
    _methods.put ("get_generation_count", new java.lang.Integer (5));
    _methods.put ("disable_notifications_for_transaction", new java.lang.Integer (6));
    _methods.put ("get_MIB_changes", new java.lang.Integer (7));
  }

  public org.omg.CORBA.portable.OutputStream _invoke (String $method,
                                org.omg.CORBA.portable.InputStream in,
                                org.omg.CORBA.portable.ResponseHandler $rh)
  {
    org.omg.CORBA.portable.OutputStream out = null;
    java.lang.Integer __method = (java.lang.Integer)_methods.get ($method);
    if (__method == null)
      throw new org.omg.CORBA.BAD_OPERATION (0, org.omg.CORBA.CompletionStatus.COMPLETED_MAYBE);

    switch (__method.intValue ())
    {

  /** Operation: subscribe
         *  Documentation:
         *      Actor invokes this operation to establish a
         *      subscription to receive configuration events. How
         *      the Actor discovers the System's address or reference
         *      (so that Actor can invoke this operation) is outside
         *      the scope of this file.
         *
         *      Parameters:
         *      (in) actorReference: It carries the Actor's IOR
         *      towards which the System pushes notifications.
         *
         *      (in) filter: It specifies a filter constraint which
         *      the system will use to filter configuration events.
         *      The system will only notify the Actor if the event
         *      satisfies the filter constraint.
         *
         *      (in) timeTick: It specifies the value of a timer
         *      held by the System for the subject actor. This
         *      value defines a time interval within which the Actor
         *      intends to invoke the get_subscription_status
         *      operation. The System will reset the timer, with
         *      timeTick when it receives the get_subscription_status
         *      operation from the subject Actor. If the timer
         *      expires, the System may delete its resources
         *      allocated to the Actor and consider the Actor as if
         *      it had invoked the unsubscribe operation. In such case,
         *      the Actor will not receive further Notifications.
         *      The Actor will need to invoke the subscribe
         *      operation again.
         *
         *      (out) subscriptionId: It carries the System
         *      assigned identifiers unique to each subscription.
         */
       case 0:  // ConfigExtended/NotificationProducer/subscribe
       {
         try {
           ConfigExtended.NotificationConsumer actorReference = ConfigExtended.NotificationConsumerHelper.read (in);
           ConfigExtended.NotificationProducerPackage.NotificationFilter filter = ConfigExtended.NotificationProducerPackage.NotificationFilterHelper.read (in);
           int timeTick = in.read_long ();
           org.omg.CORBA.IntHolder subscriptionId = new org.omg.CORBA.IntHolder ();
           this.subscribe (actorReference, filter, timeTick, subscriptionId);
           out = $rh.createReply();
           ConfigExtended.NotificationProducerPackage.SubscriptionIdHelper.write (out, subscriptionId.value);
         } catch (ConfigExtended.NotificationProducerPackage.InvalidFilterConstraintsException $ex) {
           out = $rh.createExceptionReply ();
           ConfigExtended.NotificationProducerPackage.InvalidFilterConstraintsExceptionHelper.write (out, $ex);
         }
         break;
       }


  /** Operation: subscribe_ext
         *  Documentation:
         *      See subscribe operation above. This operations does
         *      the same thing but uses a more advanced filter.
         *
         *      Parameters:
         *      (in) actorReference: It carries the Actor's IOR
         *      towards which the System pushes notifications.
         *
         *      (in) filter: It specifies a filter constraint which
         *      the System will use to filter configuration events.
         *      The System will only notify the Actor if the event
         *      satisfies the filter constraint.
         *
         *      (in) timeTick: It specifies the value of a timer
         *      held by the System for the subject actor. This
         *      value defines a time interval within which the Actor
         *      intends to invoke the get_subscription_status
         *      operation. The System will reset the timer, with
         *      timeTick when it receives the get_subscription_status
         *      operation from the subject Actor. If the timer
         *      expires, the System may delete its resources
         *      allocated to the Actor and consider the Actor as if
         *      it had invoked the unsubscribe operation. In such case,
         *      the Actor will not receive further Notifications.
         *      The Actor will need to invoke the subscribe
         *      operation again.
         *
         *      (out) subscriptionId: It carries the System
         *      assigned identifiers unique to each subscription.
         */
       case 1:  // ConfigExtended/NotificationProducer/subscribe_ext
       {
         try {
           ConfigExtended.NotificationConsumer actorReference = ConfigExtended.NotificationConsumerHelper.read (in);
           ConfigExtended.NotificationProducerPackage.NotificationFilterExt filter = ConfigExtended.NotificationProducerPackage.NotificationFilterExtHelper.read (in);
           int timeTick = in.read_long ();
           org.omg.CORBA.IntHolder subscriptionId = new org.omg.CORBA.IntHolder ();
           this.subscribe_ext (actorReference, filter, timeTick, subscriptionId);
           out = $rh.createReply();
           ConfigExtended.NotificationProducerPackage.SubscriptionIdHelper.write (out, subscriptionId.value);
         } catch (ConfigExtended.NotificationProducerPackage.InvalidFilterConstraintsException $ex) {
           out = $rh.createExceptionReply ();
           ConfigExtended.NotificationProducerPackage.InvalidFilterConstraintsExceptionHelper.write (out, $ex);
         }
         break;
       }


  /** Operation: subscribe_ext_v2
         *  Documentation:
         *      See subscribe_ext operation above. This operations does
         *      the same thing but provides backward compatibility to  
         *      older versions of OSS.  SDNs are supported only if this subscribe 
         *      version is used.
         *
         *      Parameters:
         *      (in) actorReference: It carries the Actor's IOR
         *      towards which the System pushes notifications.
         *
         *      (in) filter: It specifies a filter constraint which
         *      the System will use to filter configuration events.
         *      The System will only notify the Actor if the event
         *      satisfies the filter constraint.
         *
         *      (in) timeTick: It specifies the value of a timer
         *      held by the System for the subject actor. This
         *      value defines a time interval within which the Actor
         *      intends to invoke the get_subscription_status
         *      operation. The System will reset the timer, with
         *      timeTick when it receives the get_subscription_status
         *      operation from the subject Actor. If the timer
         *      expires, the System may delete its resources
         *      allocated to the Actor and consider the Actor as if
         *      it had invoked the unsubscribe operation. In such case,
         *      the Actor will not receive further Notifications.
         *      The Actor will need to invoke the subscribe
         *      operation again.
         *
         *      (out) subscriptionId: It carries the System
         *      assigned identifiers unique to each subscription.
         */
       case 2:  // ConfigExtended/NotificationProducer/subscribe_ext_v2
       {
         try {
           ConfigExtended.NotificationConsumer actorReference = ConfigExtended.NotificationConsumerHelper.read (in);
           ConfigExtended.NotificationProducerPackage.NotificationFilterExt filter = ConfigExtended.NotificationProducerPackage.NotificationFilterExtHelper.read (in);
           int timeTick = in.read_long ();
           org.omg.CORBA.IntHolder subscriptionId = new org.omg.CORBA.IntHolder ();
           this.subscribe_ext_v2 (actorReference, filter, timeTick, subscriptionId);
           out = $rh.createReply();
           ConfigExtended.NotificationProducerPackage.SubscriptionIdHelper.write (out, subscriptionId.value);
         } catch (ConfigExtended.NotificationProducerPackage.InvalidFilterConstraintsException $ex) {
           out = $rh.createExceptionReply ();
           ConfigExtended.NotificationProducerPackage.InvalidFilterConstraintsExceptionHelper.write (out, $ex);
         }
         break;
       }


  /** Operation: unsubscribe
         *  Documentation:
         *      Actor invokes this operation to cancel
         *      subscription.  Actor must use the same subscription
         *      Id returned by System for subscribe() and subscribe_
         *      b() operations.  This operation is mandatory.
         *
         *      Parameters:
         *      (in) subscriptionId: It carries the System assigned
         *      identifiers unique to each subscription. A unique
         *      subscriptionId is dependent on both the category
         *      and the actorReference.
         */
       case 3:  // ConfigExtended/NotificationProducer/unsubscribe
       {
         int subscriptionId = ConfigExtended.NotificationProducerPackage.SubscriptionIdHelper.read (in);
         this.unsubscribe (subscriptionId);
         out = $rh.createReply();
         break;
       }


  /** Operation: get_subscription_status
         * Documentation:
         *      The Actor invokes this operation to verify if the
         *      System has lost the Actor's reference and as a
         *      consequence, the System is not able to send
         *      information specified under Notification
         *      IRPNotifications to the Actor. This operation is
         *      mandatory.
         *
         *      Parameters:
         *      (in) subscriptionId: It carries the System assigned
         *      identifiers unique to each subscription.
         *
         *      (return): boolean set to true if the subscription still
         *      is active.
         */
       case 4:  // ConfigExtended/NotificationProducer/get_subscription_status
       {
         int subscriptionId = ConfigExtended.NotificationProducerPackage.SubscriptionIdHelper.read (in);
         boolean $result = false;
         $result = this.get_subscription_status (subscriptionId);
         out = $rh.createReply();
         out.write_boolean ($result);
         break;
       }


  /** Operation: get_generation_count
         *  Documentation:
         *      The Actor invokes this operation to verify if
         *      any reconfigurations are missed when the actor has been
         *      restarted or the contact to the NE has been lost.
         *
         *      Parameters:
         *
         *      (return): The latest generationCount.
         */
       case 5:  // ConfigExtended/NotificationProducer/get_generation_count
       {
         int $result = (int)0;
         $result = this.get_generation_count ();
         out = $rh.createReply();
         out.write_ulong ($result);
         break;
       }


  /** Operation: disable_notifications_for_transaction
         *  Documentation:
         *      The Actor invokes this operation to cancel the
         *      subscription resulting from one transaction.
         *
         *      Parameters:
         *      (in) subscriptionId: The subscription ID for the subscription
         *      to disable notifications from.
         *      (in) session: The session which contains the transaction
         *      to disable notifications from.
         */
       case 6:  // ConfigExtended/NotificationProducer/disable_notifications_for_transaction
       {
         try {
           int subscriptionId = ConfigExtended.NotificationProducerPackage.SubscriptionIdHelper.read (in);
           BasicConfig.Session session = BasicConfig.SessionHelper.read (in);
           this.disable_notifications_for_transaction (subscriptionId, session);
           out = $rh.createReply();
         } catch (ConfigExtended.NotificationProducerPackage.NoTransactionException $ex) {
           out = $rh.createExceptionReply ();
           ConfigExtended.NotificationProducerPackage.NoTransactionExceptionHelper.write (out, $ex);
         }
         break;
       }


  /** Operation: get_MIB_changes
         *  Documentation:
         *      The Actor invokes this operation to retrieve modified MOs
         *      in the MIB after the specified generationCount
         *
         *      Parameters:
         *      (in) generationCount: The last generationCount from which the
         *      subscriber received a notification. Only changes after this
         *      generationCount will be returned.
         *
         *      (return): A list of all changes in the MIB since the specified
         *      generationCount.
         *
         *      (exception): Thrown when the given generationCount is to old,
         *      that is, when more than one hundred MIB changes have occurred
         *      which is the maximum number of changes stored. In mathematical
         *      terms: ("current generationCount" - "given generationCount" > 100)
         */
       case 7:  // ConfigExtended/NotificationProducer/get_MIB_changes
       {
         try {
           int generationCount = ConfigExtended.GenerationCountTypeHelper.read (in);
           ConfigExtended.MIBChangeInfo $result[] = null;
           $result = this.get_MIB_changes (generationCount);
           out = $rh.createReply();
           ConfigExtended.MIBChangeInfoSeqHelper.write (out, $result);
         } catch (ConfigExtended.NotificationProducerPackage.ToOldGenerationCount $ex) {
           out = $rh.createExceptionReply ();
           ConfigExtended.NotificationProducerPackage.ToOldGenerationCountHelper.write (out, $ex);
         }
         break;
       }

       default:
         throw new org.omg.CORBA.BAD_OPERATION (0, org.omg.CORBA.CompletionStatus.COMPLETED_MAYBE);
    }

    return out;
  } // _invoke

  // Type-specific CORBA::Object operations
  private static String[] __ids = {
    "IDL:ConfigExtended/NotificationProducer:1.0"};

  public String[] _all_interfaces (org.omg.PortableServer.POA poa, byte[] objectId)
  {
    return (String[])__ids.clone ();
  }

  public NotificationProducer _this() 
  {
    return NotificationProducerHelper.narrow(
    super._this_object());
  }

  public NotificationProducer _this(org.omg.CORBA.ORB orb) 
  {
    return NotificationProducerHelper.narrow(
    super._this_object(orb));
  }


} // class NotificationProducerPOA
